一. 函数式编程
    1.什么是函数式编程（FP：Functional Programming）？
      函数式编程是利用纯函数来实现一些细粒度的函数，再通过函数组合将这些细粒度的函数组合成功能更强大的函数。
    2.高阶函数其实就是函数式编程的一个特性

    3.编程范式
        面向对象编程
            把现实世界中的事物抽象成程序世界中的类和对象，通过封装、继承和多态来演示事物事件的联系
        函数式编程
            把现实世界的事物和事物之间的联系抽象到程序世界（对运算过程进行抽象）；
            函数式编程中的函数指的不是程序中的函数（方法），而是数学中的函数，即映射关系；
            相同的输入始终要得到相同的输出；
            函数式编程可以让代码进行重用；
    4.函数是一等公民(First-class Function) ：头等函数
       函数可以存储在变量中；
       函数可以作为参数；
       函数可以作为返回值。
    5.高阶函数（Higher-order function）
        可以把函数作为参数传递给另一个函数；
        可以把函数另一个函数的返回结果；
    6.高阶函数的意义
        抽象可以帮我们屏蔽细节，只需要关注与我们的目标；
        高阶函数是用来抽象通用的问题；

    7.闭包：函数和其周围的状态的引用捆绑在一起形成闭包，可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员。
        闭包的本质：函数在执行的时候会翻到一个执行栈上，当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员

    8.纯函数：相同的输入永远会得到相同的输出，而且没有任何可观察的副作用，用来描述输入和输出之间的关系。
        好处：可缓存；可测试；并行处理
    
    9.函数的副作用：如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用
        副作用来源：配置文件；数据库；获取用户的输入；
        所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降，不适合扩展和可重用性

    10.柯里化：当一个函数有多个参数的时候先传递一部分参数调用它；然后返回一个新的函数接受剩余的参数，返回结果。
        柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数；
        这是一种对函数参数的缓存；
        让函数变得更灵活，让函数的粒度更小；
        可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能
    
    11.函数组合：函数组合要满足结合律；

    12.PointFree：我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。

    13.Functor（函子）：
        容器：包含值和值的变形关系
        函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有map方法，map方法可以运行一个函数对值进行处理
            函数式编程的运算不直接操作值，而是由函子完成；
            函子就是一个实现了map契约的对象；
            我们可以把函子想象成一个盒子，这个盒子里封装了一个值；
            想要处理盒子中的值，我们需要给盒子的map方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理；
            最终map方法返回一个包含新值的盒子（函子）。
    
    14.MayBe函子：我们再编程的过程中可能会遇到很多错误，需要对这些错误做相应的处理，MayBe函子的作用就是可以对外部的空值情况做处理（控制副作用在允许的范围）。

    15.Either函子: Either两者中的任何一个，类似于if...else...的处理；异常会让函数变得不纯，Either函子可以用来做异常处理。

    16.IO函子：
        IO函子中的_value是一个函数，这里是把函数作为值来处理；
        IO函子可以把不纯的动作存储到_value中，延迟执行这个不纯的操作（惰性执行），保持当前的操作纯；
        把不纯的操作交给调用者来处理。

    17.task函子：帮助我们处理异步的任务

    18.Pointed函子：实现了of静态方法的函子，避免使用new来创建对象，更深层的含义是of方法用来把值放到上下文Context中（把值放到容器中，使用map来处理值）

    19：Monad函子：
        IO函子的问题：调用时存在IO(IO(x));
        Monad函子是可以变扁（解决函数嵌套的问题）的Pointed函子；
        一个函子如果具有join和of两个方法并遵守一些定律就是一个Monad。

二、JavaScript 性能优化

    1.JavaScript内存管理：
        内存：由可读写单元组成，表示一片可操作控件
        管理：人为的去操作一片空间的申请、使用和释放
        内存管理：开发者主动申请空间、使用空间、释放空间
        管理流程：申请-------使用-------释放

    2.JavaScript中的垃圾回收：
        JavaScript中内存管理是自动的
        对象不再被引用时是垃圾
        对象不能从根上访问到时是垃圾

    3.JavaScript中的可达对象：可以访问到的对象就是可达对象（引用、作用域链）
        可达的标准就是从根出发是否能够被找到
        JavaScript中的根就可以理解为全局变量对象
    
    4.GC算法：
        GC就是垃圾回收机制的简写；GC可以找到内存中的垃圾，并释放和回收空间
        GC是一种机制，垃圾回收器完成具体的工作
        工作的内容就是查找垃圾释放空间、回收空间
        算法就是工作时查找和回收所遵循的规则
        常见GC算法：引用计数；标记清除；标记整理；分代回收
    
    5.引用计数算法实现原理：设置引用数，判断当前引用数是否为0来判断是否为垃圾
        引用计数器
        引用关系改变时修改引用数字
        引用数字为0时立即回收
    
    6.引用计数算法优缺点：
        优点：发现垃圾时立即回收；最大限度减少程序暂停
        缺点：无法回收循环引用的对象；资源消耗较大，时间开销大

    7.标记清除算法实现原理：分标记和清除两个阶段完成
        遍历所有对象找标记活动对象（活动对象为不是垃圾的对象）
        遍历所有对象清除没有标记对象（在清除过程中会清除之前的标记，方便下次垃圾回收）
        回收相应的空间（将相应回收的空间放到空间链表中）

    8.标记清除算法优缺点：
        优点：相较引用计数，能回收循环引用的对象
        缺点：空间的碎片化，不能让空间得到最大化的使用；不会立即回收垃圾对象

    9.标记整理算法实现原理：
        标记整理可以看做是标记清除的增强
        标记阶段的操作和标记清除一致
        清除阶段会先执行整理，移动对象位置，以解决标记清除中空间碎片化问题
    
    10.认识V8：一款主流的JavaScript执行引擎；采用即时编译；设有内存上限（64位操作系统不超过1.5G；32位操作系统不超过800M）

    11.V8垃圾回收策略：
        采用分代回收的思想
        内存分为新生代、老生代
        针对不同对象采用不同算法
        V8中常用GC算法：分代回收；空间复制；标记清除；标记整理；标记增量
    
    12.V8如何回收新生代对象：
        V8内存分配：
            V8内存空间一分为二；小空间用于存储新生代对象（32M|16M）；新生代指的是存活时间较短的对象
        新生代对象回收实现：
            回收过程采用复制算法+标记整理；新生代内存区为两个等大小空间；使用空间为From，空闲空间为To；活动对象存储于From空间；标记整理后将活动对象拷贝至To；From与To交换空间完成释放。
        回收细节说明：
            拷贝过程中可能出现晋升；晋升就是将新生代对象移动至老生代；一轮GC还存活的新生代需要晋升；To空间的使用率超过25%也需要晋升
    
    13.V8如何回收老生代对象：
        老生代对象说明：
            老生代对象存放在右侧老生代区域；
            64位操作系统1.4G，32位操作系统700M；
            老生代对象就是指存活时间较长的对象；
        老生代对象回收实现：
            主要采用标记清除、标记整理、增量标记算法；
            首先使用标记清除完成垃圾空间的回收；
            采用标记整理进行空间优化；
            采用增量标记进行效率优化。
        细节对比：
            新生代区域垃圾回收使用空间换时间；
            老生代区域垃圾回收不适合复制算法；
    
    14.Performance工具介绍：
        GC的目的是为了实现内存空间的良性循环；
        良性循环的基石是合理使用；
        时刻关注才能确定是否合理；
        Performance提供多种监控方式，时刻监控内存
        使用步骤：
            打开浏览器输入目标网址；
            进入开发人员工具面板，选择性能；
            开启录制功能，访问具体界面；
            执行用户行为，一段时间后停止录制；
            分析界面中记录的内存信息
    
    15.内存问题的体现：
        内存问题的外在表现：
            页面出现延迟加载或经常性暂停；
            页面持续性出现糟糕的性能；
            页面的性能随时间延长越来越差。
    
    16.监控内存的几种方式：
        界定内存问题的标准：
            内存泄漏：内存使用持续升高；
            内存膨胀：在多数设备上都存在性能问题；
            频繁垃圾回收：通过内存变化图进行分析。
        监控内存的几种方式：
            浏览器任务管理器；
            Timeline时序图记录；
            堆快照查找分离DOM；
            判断是否存在频繁的垃圾回收。
    
    17.任务管理器监控内存：通过shift+esc调出任务管理器，监控内存和JavaScript内存变化

    18.Timeline记录内存：通过浏览器Performance模块定位页面具体内存增长交互。

    19.堆快照查找分离DOM：
        堆快照留存js堆照片----在内存模块中留存快照，分析js堆；
        什么是分离DOM：
            界面元素存活在DOM树上；
            垃圾对象时的DOM节点；
            分离状态的DOM节点。
    
    20.判断是否存在频繁GC：
        为什么确定频繁垃圾回收：
            GC工作时应用程序是停止的；
            频繁且过长的GC会导致应用假死；
            用户使用中感知应用卡顿；
        确定频繁的垃圾回收方式：
            Timeline中频繁的上升下降；
            任务管理器中数据频繁的增加减小。

